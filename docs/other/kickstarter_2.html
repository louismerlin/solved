<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>The Future Is SOLVED</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<style>
/*! concrete.css v3.0.0 | MIT License | github.com/louismerlin/concrete.css */
:root{--fg:#111;--bg:#fff}@media (prefers-color-scheme:dark){:root{--fg:#fff;--bg:#111}}html{font-size:1.25rem;box-sizing:border-box}*,::after,::before{box-sizing:inherit;text-decoration-thickness:.1rem}body{background:var(--bg);font-family:Helvetica,Arial,sans-serif}a,body{color:var(--fg)}body,figure{margin:0}figcaption{text-align:right;font-size:.8em;border-bottom:.2rem solid var(--fg);padding-bottom:.2rem}img{max-width:100%;height:auto}main section+section{padding:2rem 0}body>footer,body>header,body>main{margin:auto;max-width:660px;padding-left:10px;padding-right:10px;width:100%}body>header{padding-top:8rem;padding-bottom:8rem;font-size:1.2em}h1{font-size:2em}h2{font-size:1.5em}h3{font-size:1.17em}h4{font-size:1em}h5{font-size:.83em}h6{font-size:.67em}footer{text-align:center}button,input[type=button],input[type=reset],input[type=submit]{display:inline-block;vertical-align:middle;padding:.2rem .5rem;font-size:1rem;font-weight:400;margin-bottom:.5rem;background:var(--bg);color:var(--fg);border:.1rem solid var(--fg);border-radius:0;cursor:pointer}button:disabled,input[type=button]:disabled,input[type=reset]:disabled,input[type=submit]:disabled{border-style:dashed;cursor:not-allowed}ul{list-style:square}nav{margin:2rem 0}nav ul{padding:0;list-style:none}nav ul li{margin:0 .2rem;display:inline-block}fieldset{border:.1rem solid var(--fg)}label,legend{display:block;font-weight:700;margin-bottom:.4rem}input[type=email],input[type=number],input[type=password],input[type=search],input[type=tel],input[type=text],input[type=url],select,textarea{-webkit-appearance:none;-moz-appearance:none;appearance:none;box-shadow:none;box-sizing:inherit;padding:.2rem .5rem;width:100%;font-size:1rem;color:var(--fg);background-color:var(--bg);border:.1rem solid var(--fg);border-radius:0;font-family:Helvetica,Arial,sans-serif}fieldset,input,select,textarea{margin:0 0 .8rem}input::placeholder,textarea::placeholder{color:var(--fg);font-style:italic;opacity:1}table{width:100%;border-spacing:0}td,th{padding:.4rem}td:first-child,th:first-child{padding-left:0}td:last-child,th:last-child{padding-right:0}th{border-bottom:.1rem solid var(--fg);text-align:left}td{border-bottom:.05rem solid var(--fg)}blockquote,pre{margin-left:0;margin-right:0;padding:.5rem .8rem;border-left:.1rem solid var(--fg);overflow-y:hidden}pre{border:.05rem dotted var(--fg)}pre>code{white-space:pre;display:block;font-size:.8rem}progress{-moz-appearance:none;-webkit-appearance:none;display:block;height:.5rem;overflow:hidden;padding:0;width:100%;background:var(--bg);color:var(--fg);border:.1rem solid var(--fg);border-radius:0}progress::-webkit-progress-bar{background-color:var(--bg)}progress::-webkit-progress-value{background-color:var(--fg)}progress::-moz-progress-bar{background-color:var(--fg)}hr{border:.05rem solid var(--fg)}

:root {
  --neon-pink: #ec008c;
  --neon-green: #1cfe23;
  --neon-yellow: #ffff00;
  --neon-blue: #00ffff;
  --neon-orange: #ff4500;
  --neon-purple: #bf00ff;
}
html {
  font-size: 1rem;
}
body>footer, body>header, body>main {
  max-width: 960px;
}
h1 {
  font-family: monospace;
  border-left: 0.3rem solid var(--neon-yellow);
  padding-left: 0.5rem;
}
h2 {
  border-left: 0.3rem solid var(--neon-blue);
  padding-left: 0.5rem;
}
a {
  text-decoration-color: var(--neon-orange);
}
pre {
  border-left: .3rem solid var(--neon-pink);
}
blockquote {
  border-left-color: var(--neon-green);
  border-width: .3rem;
}
.hacker-note {
  border: 0.3rem solid var(--neon-purple);
  margin: 1rem 0;
  padding: 1rem;
}
.hacker-note legend {
  padding: 0 0.5rem;
  font-weight: bold;
  font-family: monospace;
}
.hacker-note > p {
  margin: 0;
}
.row {
  display: flex;
  flex-direction: column-reverse;
  padding: 0;
}
.row .column {
  display: block;
  flex: 1 1 auto;
  margin-left: 0;
  max-width: 100%;
  width: 100%;
}
img {
  image-rendering: pixelated;
  width: 100%;
}
@media (min-width: 30.0rem) {
  .row {
    flex-direction: row;
    margin: 0 -.5rem;
    width: calc(100% + 1rem);
    align-items: stretch;
  }
  .row .column {
    margin-bottom: inherit;
    padding: 0 .5rem;
  }
  .row .column.img-column {
    display: flex;
    justify-content: center;
    align-items: center; 
  }
  .row .column.img-column img {
    max-width: 50%;
    box-shadow: 0 0 .5rem #111;
  }
}
</style>
</head>
<body>
<main>
<br>
<p><a href="../index.html">back to home</a></p>
<h1>Kickstarter 2 Challenges</h1>
<p>You'll find these challenges dispersed in the <a href="https://www.kickstarter.com/projects/rekcah/support-comic-shops-with-the-future-is-xxxxxx-origins-hc">Kickstarter page</a> for the second crowdfunding campaign of the comic book series.</p>
<p>All four challenges are dispersed in the &quot;Campaign&quot; page.</p>
<h2>Challenge 1</h2>
<p>For the first challenge we get the word &quot;ROT13&quot; and what looks like a gibberish url.
<a href="https://en.wikipedia.org/wiki/ROT13">ROT13</a> is a version of the Caesar cipher with 13 rotations.</p>
<p><a href="https://gchq.github.io/CyberChef/">CyberChef</a> has a <code>ROT13</code> recipe we can use to decode the URL.</p>
<p>Going to that URL will give us a bonus flag. One down, three to go!</p>
<h2>Challenge 2</h2>
<p>Next, we are given the word &quot;HEX&quot; and a long hexadecimal string.</p>
<p><a href="https://gchq.github.io/CyberChef/">CyberChef</a> has a <code>From Hex</code> recipe, we use that to get to the second stage of the challenge.</p>
<p>The decoded string contains <code>Z-&gt;A</code> and another gibberish url, similar to the one in challenge 1.</p>
<p><code>Z-&gt;A</code> must be the key to decrypting the URL. Let's try to figure out what it means.</p>
<p>We are only given <code>Z-&gt;A</code> so let's assume at every step that this is as simple as possible. We can add complications later if it does not work.</p>
<p>If <code>Z</code> becomes <code>A</code>, then <code>A</code> becomes <code>Z</code>.</p>
<p>If <code>Z</code> becomes <code>A</code> and <code>A</code> becomes <code>Z</code>, then <code>Y</code> becomes <code>B</code> and <code>B</code> becomes <code>Y</code>.</p>
<p>... repeat until <code>N</code> becomes <code>M</code> ...</p>
<p>Ok this looks like an interesting algorithm, let's try it out!</p>
<p>Yup, that's the solution, cool, we get a second bonus flag.</p>
<h2>Challenge 3</h2>
<p>The third challenge has the word <code>BASE?</code> and a bunch of letters and numbers next to it.</p>
<p>It seems quite straightforward, we need to figure out the <a href="https://simple.wikipedia.org/wiki/Base_(mathematics)">base</a> of the string and decode it.</p>
<p>Using our good friend <a href="https://gchq.github.io/CyberChef/">CyberChef</a>, we try different common <code>From BaseXX</code> recipes. The one for <code>Base32</code> gives us a url!</p>
<h3>The Authentication</h3>
<p>Yay, the url has a second challenge in addition to the bonus flag.</p>
<p>We are given a python function, and asked to figure out the correct password to get the flag.</p>
<p>The python function runs the <code>check</code> function on the user-provided input.
This <code>check</code> function does some transformation on the input and compares it with a secret that we have access to.</p>
<p>The <code>check</code> function will return <code>True</code> if the user-provided input is the flag. This means we have to reverse-engineer the following transformation:</p>
<pre><code class="language-python">entered = [ord(c) ^ 0x13 for c in pwd[::2]] + [ord(c) ^ 0x37 for c in pwd[1::2]]

# ok we can split this into two separate arrays:
entered_1 = [ord(c) ^ 0x13 for c in pwd[::2]]
entered_2 = [ord(c) ^ 0x37 for c in pwd[1::2]]
entered = entered_1 + entered_2 # &lt;- concatenation

# now let's try to write it in pseudo-code:
entered_1 = (char_to_int(element) XOR 19) for each second element of the input (starting with index 0)
entered_2 = (char_to_int(element) XOR 55) for each second element of the input (starting with index 1)
entered = concatenate entered_1 and entered_2

# now let's reverse it:
key_even = element XOR 19 for each element in the first half of the secret
key_odd = element XOR 55 for each element in the second half of the secret
key_int = intertwine key_even and key_odd (key_even[0], then key_odd[0], then key_even[1] etc)
key = apply int_to_char to every element of key_int

# in real python this gives us:
key_even = [e ^ 19 for e in secret[:(len(secret)+1)//2]]
key_odd = [e ^ 55 for e in secret[(len(secret)+1)//2:]]
pwd = []
for i in range(n):
    if i % 2 == 0:
        pwd.append(chr(key_even[i // 2]))
    else:
        pwd.append(chr(key_odd[i // 2]))
print(''.join(pwd))
</code></pre>
<p>This gives us the flag.</p>
<h2>Challenge 4</h2>
<p>We are given the word <code>XOR</code> and a long hexadecimal string.</p>
<p>As we are not given the key to decipher the XOR-encrypted string, we have to be clever. The <a href="https://en.wikipedia.org/wiki/XOR_cipher">XOR cipher</a> is reversible, meaning that <code>ciphertext = xor(plaintext, key)</code> and <code>plaintext = xor(ciphertext, key)</code> but also <code>key = xor(ciphertext, plaintext)</code>.
We know the ciphertext, so if we could figure out parts of the plaintext we could maybe figure out parts of the key.</p>
<p>Almost all of the other challenges for this CTF have the same base URL, <code>tficomic.io</code>. We can be almost sure that the plaintext begins with these letters.</p>
<p>Using <a href="https://gchq.github.io/CyberChef/">CyberChef</a>, we use the <code>From Hex</code> and <code>XOR</code> recipes and put <code>tficomic.io/</code> in the <code>Key</code> box (make sure to select <code>UTF8</code> in the dropdown).
The output is not recognizable but it does look like the beginning is repeating every two characters!
We add the <code>To Hex</code> recipe and see that the first two bytes are repeating: <code>0eca</code> for as long as the plaintext is known.</p>
<p>We can deduce that the key is <code>0eca</code> and repeats for the entire word.</p>
<p>We now replace the <code>Key</code> field with <code>0eca</code> (make sure to select <code>Hex</code> in the dropdown) and disable the <code>To Hex</code> operation.</p>
<p>Here is our URL!</p>
<h2>The Network</h2>
<p>There is the real challenge at the given URL, as well as a bonus flag.</p>
<p>We are given a <code>pcapng</code> file, which is a network capture file we can open with <a href="https://www.wireshark.org">Wireshark</a>.</p>
<p>The challenge page tells us this is the capture of someone downloading a ZIP file, and that the password for the ZIP is on the website from which the file was downloaded.</p>
<p>Opening-up the <code>pcapng</code> with Wireshark, let's first find that ZIP file. We scroll down to the bottom, and click on the last HTTP packet, which says <code>OK (application/zip)</code>.
We right-click, <code>Follow</code>, <code>HTTP Stream</code>. In that new page we <code>Show as</code> <code>Raw</code> and then <code>Save as...</code>. Now we've got our zip file.</p>
<p>Next step: find the password. Scrolling back up to the top, we find the line that says <code>200 OK (text/html)</code>. We click on it, and then in the bottom-right panel click on &quot;Reassembled TCP&quot;. We can now scroll down through the HTML content, and find the password in the <code>&lt;input&gt;</code> field.</p>
<p>Unzipping the file with the password, we get an image of the flag. Success!</p>
<br>
<br>
<footer>
<p>
<a href="https://louismerl.in/">Louis Merlin</a> Â© <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">BY-NC-SA 4.0</a> | <a href="https://github.com/louismerlin/solved/">Code</a>
</p>
</footer>
</main>
</body>
</html>
